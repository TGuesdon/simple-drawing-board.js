!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).SimpleDrawingBoard={})}(this,(function(t){"use strict";class e{constructor(){this._events={}}on(t,e){const s=this._events;t in s||(s[t]=[]),s[t].push(e)}off(t,e){const s=this._events;if(!(t in s))return;e||(s[t]=[]);const i=s[t].indexOf(e);i>=0&&s[t].splice(i,1)}trigger(t,e){const s=this._events;if(t in s)for(let i=0;i<s[t].length;i++){const o=s[t][i];o.handleEvent?o.handleEvent.call(this,e):o.call(this,e)}}removeAllListeners(){this._events={}}}class s{constructor(t=null){this._past=[],this._present=t,this._future=[]}get value(){return this._present}undo(){if(0===this._past.length)return;const t=this._past.pop();this._future.unshift(this._present),this._present=t}redo(){if(0===this._future.length)return;const t=this._future.shift();this._past.push(this._present),this._present=t}save(t){this._present!==t&&(this._past.push(this._present),this._future.length=0,this._present=t)}clear(){this._past.length=0,this._future.length=0}}function i(){return"ontouchstart"in window.document}function o(t){return"string"==typeof t&&!!t.startsWith("data:image/")}async function a(t){return new Promise(((e,s)=>{const i=new Image;i.onerror=s,i.onload=()=>e(i),i.src=t}))}function r(t,e){return{x:t.x+e.x>>1,y:t.y+e.y>>1}}function n(t,e){let s,o;i()?(s=t.touches[0].pageX,o=t.touches[0].pageY):(s=t.pageX,o=t.pageY);const a=e.getBoundingClientRect(),r=a.left+window.pageXOffset,n=a.top+window.pageYOffset;return{x:(s-r)*(e.width/a.width),y:(o-n)*(e.height/a.height)}}const h="draw",c="erase",_="flood";class d{constructor(t){this._$el=t,this._ctx=this._$el.getContext("2d"),this._ctx.lineCap=this._ctx.lineJoin="round",this._drawMode=h,this._isFlooding=!1,this._isDrawing=!1,this._timer=null,this._coords={old:{x:0,y:0},oldMid:{x:0,y:0},current:{x:0,y:0}},this._imageData=void 0,this._ev=new e,this._history=new s(this.toDataURL()),this.fill("#ffffff"),this._bindEvents(),this._drawFrame()}get canvas(){return this._$el}get observer(){return this._ev}get mode(){return this._drawMode}setLineSize(t){this._ctx.lineWidth=0|t||1}setLineColor(t){this._ctx.strokeStyle=t}fill(t){const e=this._ctx;e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillStyle=t,e.fillRect(0,0,e.canvas.width,e.canvas.height),this._saveHistory()}clear(){const t=this._ctx;t.clearRect(0,0,t.canvas.width,t.canvas.height),this._saveHistory()}toggleMode(t){if("DRAW"==t||"ERASE"==t||"FLOOD"==t)switch(t){case"DRAW":this._ctx.globalCompositeOperation="source-over",this._drawMode=h;break;case"ERASE":this._ctx.globalCompositeOperation="destination-out",this._drawMode=c;break;case"FLOOD":this._ctx.globalCompositeOperation="source-over",this._drawMode=_}else console.log("Error: Invalid drawing mode")}toDataURL({type:t,quality:e}={}){return this._ctx.canvas.toDataURL(t,e)}fillImageByElement(t,{isOverlay:e=!1}={}){if(!function(t){return t instanceof HTMLImageElement||t instanceof SVGImageElement||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement}(t))throw new TypeError("Passed element is not a drawable!");const s=this._ctx;e||s.clearRect(0,0,s.canvas.width,s.canvas.height),s.drawImage(t,0,0,s.canvas.width,s.canvas.height),this._saveHistory()}async fillImageByDataURL(t,{isOverlay:e=!1}={}){if(!o(t))throw new TypeError("Passed src is not a base64 data URL!");const s=await a(t),i=this._ctx;e||i.clearRect(0,0,i.canvas.width,i.canvas.height),i.drawImage(s,0,0,i.canvas.width,i.canvas.height),this._saveHistory()}async undo(){this._history.undo();const t=this._history.value;if(!o(t))return;const e=await a(t),s=this._ctx;s.clearRect(0,0,s.canvas.width,s.canvas.height),s.drawImage(e,0,0,s.canvas.width,s.canvas.height)}async redo(){this._history.redo();const t=this._history.value;if(!o(t))return;const e=await a(t),s=this._ctx;s.clearRect(0,0,s.canvas.width,s.canvas.height),s.drawImage(e,0,0,s.canvas.width,s.canvas.height)}destroy(){this._unbindEvents(),this._ev.removeAllListeners(),this._history.clear(),cancelAnimationFrame(this._timer),this._timer=null}handleEvent(t){switch(t.preventDefault(),t.stopPropagation(),t.type){case"mousedown":case"touchstart":this._onInputDown(t);break;case"mousemove":case"touchmove":this._onInputMove(t);break;case"mouseup":case"touchend":this._onInputUp();break;case"mouseout":case"touchcancel":case"gesturestart":this._onInputCancel()}}_bindEvents(){const t=i()?["touchstart","touchmove","touchend","touchcancel","gesturestart"]:["mousedown","mousemove","mouseup","mouseout"];for(const e of t)this._$el.addEventListener(e,this,!1)}_unbindEvents(){const t=i()?["touchstart","touchmove","touchend","touchcancel","gesturestart"]:["mousedown","mousemove","mouseup","mouseout"];for(const e of t)this._$el.removeEventListener(e,this,!1)}_drawFrame(){this._timer=requestAnimationFrame((()=>this._drawFrame())),this._isDrawing&&(this._drawMode!=h&&this._drawMode!=c||this._drawWithPen())}_drawWithPen(){const t=this._coords.old.x===this._coords.current.x&&this._coords.old.y===this._coords.current.y,e=r(this._coords.old,this._coords.current),s=this._ctx;s.beginPath(),s.moveTo(e.x,e.y),s.quadraticCurveTo(this._coords.old.x,this._coords.old.y,this._coords.oldMid.x,this._coords.oldMid.y),s.stroke(),this._coords.old=this._coords.current,this._coords.oldMid=e,t||this._ev.trigger("draw",this._coords.current)}_drawFlood(){if(this._isFlooding)return;this._isFlooding=!0;const t=Math.floor(this._coords.current.x),e=Math.floor(this._coords.current.y),s=this._ctx.canvas.width,i=this._ctx.canvas.height;this._imageData=this._ctx.getImageData(0,0,s,i);let o=[[t,e]];const a=4*(e*s+t),r=this._hexToRgbA(this._ctx.strokeStyle),n=this._getTargetColor(a);if(console.log(r),console.log(n),r[0]!=n[0]||r[1]!=n[1]||r[2]!=n[2]){for(;o.length>0;){var h,c,_,d,l,u;for(c=(h=o.pop())[0],d=4*((_=h[1])*s+c);_-- >=0&&this._matchStartColor(d,n);)d-=4*s;for(d+=4*s,++_,l=!1,u=!1;_++<i-1&&this._matchStartColor(d,n);)this._colorPixel(d,r),c>0&&_>0&&c<s-1&&_<=i-1&&(this._matchStartColor(d-4,n)?l||(o.push([c-1,_]),l=!0):l&&(l=!1)),c>0&&_>0&&c<s-1&&_<=i-1&&(this._matchStartColor(d+4,n)?u||(o.push([c+1,_]),u=!0):u&&(u=!1)),d+=4*s}this._isFlooding=!1,this._ctx.putImageData(this._imageData,0,0)}else this._isFlooding=!1}_matchStartColor(t,e){var s=this._imageData.data[t],i=this._imageData.data[t+1],o=this._imageData.data[t+2];return s==e[0]&&i==e[1]&&o==e[2]}_hexToRgbA(t){var e;if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(t))return 3==(e=t.substring(1).split("")).length&&(e=[e[0],e[0],e[1],e[1],e[2],e[2]]),[(e="0x"+e.join(""))>>16&255,e>>8&255,255&e];throw new Error("Bad Hex")}_getTargetColor(t){return[this._imageData.data[t],this._imageData.data[t+1],this._imageData.data[t+2]]}_colorPixel(t,e){this._imageData.data[t]=e[0],this._imageData.data[t+1]=e[1],this._imageData.data[t+2]=e[2],this._imageData.data[t+3]=255}_onInputDown(t){this._isDrawing=!0;const e=n(t,this._$el);switch(this._coords.current=this._coords.old=e,this._coords.oldMid=r(this._coords.old,e),this._drawMode){case h:this._ev.trigger("drawBegin",this._coords.current);break;case c:this._ev.trigger("eraseBegin",this._coords.current);break;case _:this._ev.trigger("floodBegin",this._coords.current),this._drawFlood()}}_onInputMove(t){this._coords.current=n(t,this._$el)}_onInputUp(){this._ev.trigger("drawEnd",this._coords.current),this._saveHistory(),this._isDrawing=!1}_onInputCancel(){this._isDrawing&&(this._ev.trigger("drawEnd",this._coords.current),this._saveHistory()),this._isDrawing=!1}_saveHistory(){this._history.save(this.toDataURL()),this._ev.trigger("save",this._history.value)}}t.create=function(t){if(!(t instanceof HTMLCanvasElement))throw new TypeError("HTMLCanvasElement must be passed as first argument!");return new d(t)},Object.defineProperty(t,"__esModule",{value:!0})}));
